{
 * NsWebServices.UBase.pas
 *
 * Provides a base class for all objects that access web services.
 *
 * $Rev$
 * $Date$
 *
 * ***** BEGIN LICENSE BLOCK *****
 *
 * Version: MPL 1.1
 *
 * The contents of this file are subject to the Mozilla Public License Version
 * 1.1 (the "License"); you may not use this file except in compliance with the
 * License. You may obtain a copy of the License at http://www.mozilla.org/MPL/
 *
 * Software distributed under the License is distributed on an "AS IS" basis,
 * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License for
 * the specific language governing rights and limitations under the License.
 *
 * The Original Code is NsWebServices.UBase.pas
 *
 * The Initial Developer of the Original Code is Peter Johnson
 * (http://www.delphidabbler.com/).
 *
 * Portions created by the Initial Developer are Copyright (C) 2010 Peter
 * Johnson. All Rights Reserved.
 *
 * Contributor(s)
 *   NONE
 *
 * ***** END LICENSE BLOCK *****
}


unit NsWebServices.UBase;

interface

uses
  SysUtils, Classes,

  IdHTTP, IdAntiFreeze, IdException,

  NsWebServices.UCharEncodings,
  UDownloadMonitor, // rename this into NsWebServices namespace
  UURIParams,
  UWebInfo;   // MAYBE rename this into NsWebWervices namespace

type

  {
  TWebServiceProgressEvent:
    Type of event handler used to handle TWebService.OnProgress events. Used to
    monitor download progress.
      @param Sender [in] Reference to TWebService object triggering event.
      @param BytesToDate [in] Number of bytes downloaded.
      @param BytesExpected [in] Total number of bytes to be downloaded.
  }
  TWebServiceProgressEvent = procedure(Sender: TObject; const BytesToDate,
    BytesExpected: Integer) of object;

  TBaseWebService = class(TObject)
  private
    fHTTP: TIdHTTP;
    fAntiFreeze: TIdAntiFreeze;
    fScriptURI: string;
    fDownloadMonitor: TDownloadMonitor;
    fOnProgress: TWebServiceProgressEvent;
    fWantProgress: Boolean;     // Monitors download progress
  strict private
    procedure ValidateContent(const Content: TStream);
    function DoRequestAsText(const Requestor: TProc<TBytesStream>): string;
    function DoRequestRaw(const Requestor: TProc<TBytesStream>): TBytes;
    procedure DoPostParams(const Params: TURIParams;
      const PostProc: TProc<TStream>);
    function BuildURI(const Params: TURIParams = nil): string;
  strict protected
    procedure HandleException(const E: EIdException);
      {Handles likely exceptions generated by HTTP component and translates into
      own exception objects that are not detected as bugs and have more user
      friendly error messages.
        @param E [in] Exception to translate.
        @except EHTTPError raised if EIdHTTPProtocolException encountered.
        @except EWebConnectionError raised if EIdSocketError encoutered.
        @except EIdException or descendants re-raised for other exception types.
      }
    procedure DoProgress; virtual;
      {Called when download progress information changes. Does nothing.
      Descendants can trigger OnProgress events by calling the
      TriggerProgressEvent method.
      }
    property WantProgress: Boolean read fWantProgress write fWantProgress;
  public // make these protected after testing
    function GetRaw(const Params: TURIParams = nil): TBytes;
    function GetText(const Params: TURIParams = nil): string;
    procedure GetStrings(const Params: TURIParams; const Strings: TStrings);
      overload;
    procedure GetStrings(const Strings: TStrings); overload;
    function PostRaw(const Data: TStream): TBytes; overload;
    function PostText(const Data: TStream): string; overload;
    function PostRaw(const Params: TURIParams): TBytes; overload;
    function PostText(const Params: TURIParams): string; overload;
    procedure PostStrings(const Data: TStream; const Strings: TStrings);
      overload;
    procedure PostStrings(const Params: TURIParams; const Strings: TStrings);
      overload;
  public
    constructor Create(const WebInfo: TWebServiceInfo);
    destructor Destroy; override;
    property OnProgress: TWebServiceProgressEvent
      read fOnProgress write fOnProgress;
      {Event that can be triggered to monitor progress of downloads. Not
      triggered by default. Descendant classes can trigger the event by
      overriding the DoProgress method and calling TriggerProgressEvent inside
      the overridden method}
  end;


implementation

uses
  IdCoderMIME, IdStack,
  NsWebServices.UExceptions,
  UConsts,
  PJMD5;

resourcestring
  // Error messages
  sWebConnectionError = 'There was a problem accessing the internet. Please '
    + 'check your web connection. '
    + 'If you are using a proxy server please check its configuration.'
    + EOL2
    + 'The error reported by Windows was: %0:s.';
  sWebValidationError = 'Validation error: checksum failed. The may have been '
    + 'a transmission error';

function Base64Decode(const EncodedText: string): TBytes;
var
  DecodedStm: TBytesStream;
  Decoder: TIdDecoderMIME;
begin
  Decoder := TIdDecoderMIME.Create(nil);
  try
    DecodedStm := TBytesStream.Create;
    try
      Decoder.DecodeBegin(DecodedStm);
      Decoder.Decode(EncodedText);
      Decoder.DecodeEnd;
      Result := DecodedStm.Bytes;
    finally
      DecodedStm.Free;
    end;
  finally
    Decoder.Free;
  end;
end;

{ TBaseWebService }

function TBaseWebService.BuildURI(const Params: TURIParams): string;
begin
  if not Assigned(Params) or Params.IsEmpty then
    Result := fScriptURI
  else
    Result := fScriptURI + '?' + Params.EncodedQueryString;
end;

constructor TBaseWebService.Create(const WebInfo: TWebServiceInfo);
var
  ProxyInfo: TWebProxyInfo; // details on any proxy server
begin
  inherited Create;
  fAntiFreeze :=  TIdAntiFreeze.Create(nil);
  fHTTP := TIdHTTP.Create(nil);
  fHTTP.HTTPOptions := fHTTP.HTTPOptions - [hoForceEncodeParams];
  fHTTP.Request.UserAgent := WebInfo.UserAgent;
  fHTTP.Request.Accept := WebInfo.MediaType + ', */*';
  fHTTP.Request.AcceptCharSet := TWSCharEncodings.AcceptCharSet;
  fHTTP.Request.AcceptLanguage := 'en-gb, en;q=0.8';
  if ProxyInfo.UseProxy then
  begin
    fHTTP.ProxyParams.ProxyServer := ProxyInfo.IPAddress;
    fHTTP.ProxyParams.ProxyPort := ProxyInfo.Port;
    fHTTP.ProxyParams.ProxyUsername := ProxyInfo.UserName;
    fHTTP.ProxyParams.ProxyPassword := ProxyInfo.Password;
  end;
  // Record script URI for future use
  fScriptURI := WebInfo.ScriptURI;
  // Create object that monitors download progress
  fDownloadMonitor := TDownloadMonitor.Create(fHTTP, DoProgress);
end;

destructor TBaseWebService.Destroy;
begin
  fDownloadMonitor.Free;
  fHTTP.Free;
  fAntiFreeze.Free;
  inherited;
end;

procedure TBaseWebService.DoPostParams(const Params: TURIParams;
  const PostProc: TProc<TStream>);
var
  Data: TStream;
begin
  Data := TBytesStream.Create(
    TEncoding.ASCII.GetBytes(Params.EncodedQueryString)
  );
  Data.Position := 0;
  try
    fHTTP.Request.ContentType := 'application/x-www-form-urlencoded';
    try
      PostProc(Data);
    finally
      fHTTP.Request.ContentType := '';
    end;
  finally
    Data.Free;
  end;
end;

procedure TBaseWebService.DoProgress;
begin
  if fWantProgress and Assigned(fOnProgress) then
    fOnProgress(
      Self, fDownloadMonitor.BytesReceived, fDownloadMonitor.BytesExpected
    );
end;

function TBaseWebService.DoRequestAsText(const Requestor: TProc<TBytesStream>):
  string;
var
  Content: TBytes;
  Encoding: TEncoding;
begin
  Content := DoRequestRaw(Requestor); // performs HTTP request
  if AnsiPos('text/', fHTTP.Response.ContentType) = 0 then
    raise Exception.Create('Text content expected');
  Encoding := TWSCharEncodings.GetEncoding(fHTTP.Response.CharSet);
  try
    Result := Encoding.GetString(Content);
  finally
    if not TEncoding.IsStandardEncoding(Encoding) then
      Encoding.Free;
  end;
end;

function TBaseWebService.DoRequestRaw(
  const Requestor: TProc<TBytesStream>): TBytes;
var
  Response: TBytesStream;
begin
  // set up request
  Response := TBytesStream.Create;
  try
    // do request
    try
      Requestor(Response);
    except
      on E: EIdException do
        HandleException(E);
    end;
    Response.Position := 0;
    // process reponse
    if fHTTP.Response.HasContentLength then
      Response.SetSize(fHTTP.Response.ContentLength);
    if fHTTP.Response.RawHeaders.IndexOfName('Content-MD5') >= 0 then
      ValidateContent(Response);
    Result := Response.Bytes;
  finally
    Response.Free;
  end;
end;

function TBaseWebService.GetRaw(const Params: TURIParams): TBytes;
begin
  Result := DoRequestRaw(
    procedure(AResponse: TBytesStream)
    begin
      fHTTP.Get(BuildURI(Params), AResponse)
    end
  )
end;

procedure TBaseWebService.GetStrings(const Strings: TStrings);
begin
  GetStrings(nil, Strings);
end;

procedure TBaseWebService.GetStrings(const Params: TURIParams;
  const Strings: TStrings);
begin
  Strings.Text := Trim(GetText(Params));
end;

function TBaseWebService.GetText(const Params: TURIParams): string;
begin
  Result := DoRequestAsText(
    procedure(AResponse: TBytesStream)
    begin
      fHTTP.Get(BuildURI(Params), AResponse)
    end
  )
end;

procedure TBaseWebService.HandleException(const E: EIdException);
begin
  if E is EIdHTTPProtocolException then
    raise EHTTPError.Create(E as EIdHTTPProtocolException)
  else if E is EIdSocketError then
    raise EWebConnectionError.CreateFmt(sWebConnectionError, [Trim(E.Message)])
  else
    raise E;
end;

function TBaseWebService.PostRaw(const Params: TURIParams): TBytes;
var
  RetVal: TBytes;
begin
  DoPostParams(
    Params,
    procedure(Data: TStream)
    begin
      RetVal := PostRaw(Data);
    end
  );
  Result := RetVal;
end;

procedure TBaseWebService.PostStrings(const Params: TURIParams;
  const Strings: TStrings);
begin
  Strings.Text := Trim(PostText(Params));
end;

procedure TBaseWebService.PostStrings(const Data: TStream;
  const Strings: TStrings);
begin
  Strings.Text := Trim(PostText(Data));
end;

function TBaseWebService.PostText(const Data: TStream): string;
begin
  Result := DoRequestAsText(
    procedure(AResponse: TBytesStream)
    begin
      fHTTP.Post(fScriptURI, Data, AResponse)
    end
  );
end;

function TBaseWebService.PostText(const Params: TURIParams): string;
var
  RetVal: string;
begin
  DoPostParams(
    Params,
    procedure(Data: TStream)
    begin
      RetVal := PostText(Data);
    end
  );
  Result := RetVal;
end;

function TBaseWebService.PostRaw(const Data: TStream): TBytes;
begin
  Result := DoRequestRaw(
    procedure(AResponse: TBytesStream)
    begin
      fHTTP.Post(fScriptURI, Data, AResponse)
    end
  );
end;

procedure TBaseWebService.ValidateContent(const Content: TStream);
var
  HeaderMD5Encoded: string;
  HeaderMD5: TPJMD5Digest;
  ContentMD5: TPJMD5Digest;
begin
  HeaderMD5Encoded := fHTTP.Response.RawHeaders.Values['Content-MD5'];
  HeaderMD5 := Base64Decode(HeaderMD5Encoded);
  ContentMD5 := TPJMD5.Calculate(Content);
  if HeaderMD5 <> ContentMD5 then
    raise EWebServiceFailure.Create(sWebValidationError);
end;

end.
